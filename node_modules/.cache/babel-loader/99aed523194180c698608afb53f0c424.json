{"ast":null,"code":"import _objectWithoutProperties from \"/Users/guokai/Desktop/React-connect/node_modules/@babel/runtime/helpers/esm/objectWithoutProperties\";\nimport _objectSpread from \"/Users/guokai/Desktop/React-connect/node_modules/@babel/runtime/helpers/esm/objectSpread2\";\nvar _jsxFileName = \"/Users/guokai/Desktop/React-connect/src/Editor/index.js\";\n\n/* global global */\nimport * as React from \"react\";\nconst KEYCODE_ENTER = 13;\nconst KEYCODE_TAB = 9;\nconst KEYCODE_BACKSPACE = 8;\nconst KEYCODE_Y = 89;\nconst KEYCODE_Z = 90;\nconst KEYCODE_M = 77;\nconst KEYCODE_PARENS = 57;\nconst KEYCODE_BRACKETS = 219;\nconst KEYCODE_QUOTE = 222;\nconst KEYCODE_BACK_QUOTE = 192;\nconst KEYCODE_ESCAPE = 27;\nconst HISTORY_LIMIT = 100;\nconst HISTORY_TIME_GAP = 3000;\nconst isWindows = \"navigator\" in global && /Win/i.test(navigator.platform);\nconst isMacLike = \"navigator\" in global && /(Mac|iPhone|iPod|iPad)/i.test(navigator.platform);\nconst className = \"npm__react-simple-code-editor__textarea\";\nconst cssText =\n/* CSS */\n`\n/**\n * Reset the text fill color so that placeholder is visible\n */\n.${className}:empty {\n  -webkit-text-fill-color: inherit !important;\n}\n\n/**\n * Hack to apply on some CSS on IE10 and IE11\n */\n@media all and (-ms-high-contrast: none), (-ms-high-contrast: active) {\n  /**\n    * IE doesn't support '-webkit-text-fill-color'\n    * So we use 'color: transparent' to make the text transparent on IE\n    * Unlike other browsers, it doesn't affect caret color in IE\n    */\n  .${className} {\n    color: transparent !important;\n  }\n\n  .${className}::selection {\n    background-color: #accef7 !important;\n    color: transparent !important;\n  }\n}\n`;\nexport default class Editor extends React.Component {\n  constructor(...args) {\n    super(...args);\n    this.state = {\n      capture: true\n    };\n\n    this._recordCurrentState = () => {\n      const input = this._input;\n      if (!input) return; // Save current state of the input\n\n      const value = input.value,\n            selectionStart = input.selectionStart,\n            selectionEnd = input.selectionEnd;\n\n      this._recordChange({\n        value,\n        selectionStart,\n        selectionEnd\n      });\n    };\n\n    this._getLines = (text, position) => text.substring(0, position).split(\"\\n\");\n\n    this._recordChange = (record, overwrite = false) => {\n      const _this$_history = this._history,\n            stack = _this$_history.stack,\n            offset = _this$_history.offset;\n\n      if (stack.length && offset > -1) {\n        // When something updates, drop the redo operations\n        this._history.stack = stack.slice(0, offset + 1); // Limit the number of operations to 100\n\n        const count = this._history.stack.length;\n\n        if (count > HISTORY_LIMIT) {\n          const extras = count - HISTORY_LIMIT;\n          this._history.stack = stack.slice(extras, count);\n          this._history.offset = Math.max(this._history.offset - extras, 0);\n        }\n      }\n\n      const timestamp = Date.now();\n\n      if (overwrite) {\n        const last = this._history.stack[this._history.offset];\n\n        if (last && timestamp - last.timestamp < HISTORY_TIME_GAP) {\n          // A previous entry exists and was in short interval\n          // Match the last word in the line\n          const re = /[^a-z0-9]([a-z0-9]+)$/i; // Get the previous line\n\n          const previous = this._getLines(last.value, last.selectionStart).pop().match(re); // Get the current line\n\n\n          const current = this._getLines(record.value, record.selectionStart).pop().match(re);\n\n          if (previous && current && current[1].startsWith(previous[1])) {\n            // The last word of the previous line and current line match\n            // Overwrite previous entry so that undo will remove whole word\n            this._history.stack[this._history.offset] = _objectSpread({}, record, {\n              timestamp\n            });\n            return;\n          }\n        }\n      } // Add the new operation to the stack\n\n\n      this._history.stack.push(_objectSpread({}, record, {\n        timestamp\n      }));\n\n      this._history.offset++;\n    };\n\n    this._updateInput = record => {\n      const input = this._input;\n      if (!input) return; // Update values and selection state\n\n      input.value = record.value;\n      input.selectionStart = record.selectionStart;\n      input.selectionEnd = record.selectionEnd;\n      this.props.onValueChange(record.value);\n    };\n\n    this._applyEdits = record => {\n      // Save last selection state\n      const input = this._input;\n      const last = this._history.stack[this._history.offset];\n\n      if (last && input) {\n        this._history.stack[this._history.offset] = _objectSpread({}, last, {\n          selectionStart: input.selectionStart,\n          selectionEnd: input.selectionEnd\n        });\n      } // Save the changes\n\n\n      this._recordChange(record);\n\n      this._updateInput(record);\n    };\n\n    this._undoEdit = () => {\n      const _this$_history2 = this._history,\n            stack = _this$_history2.stack,\n            offset = _this$_history2.offset; // Get the previous edit\n\n      const record = stack[offset - 1];\n\n      if (record) {\n        // Apply the changes and update the offset\n        this._updateInput(record);\n\n        this._history.offset = Math.max(offset - 1, 0);\n      }\n    };\n\n    this._redoEdit = () => {\n      const _this$_history3 = this._history,\n            stack = _this$_history3.stack,\n            offset = _this$_history3.offset; // Get the next edit\n\n      const record = stack[offset + 1];\n\n      if (record) {\n        // Apply the changes and update the offset\n        this._updateInput(record);\n\n        this._history.offset = Math.min(offset + 1, stack.length - 1);\n      }\n    };\n\n    this._handleKeyDown = e => {\n      const _this$props = this.props,\n            tabSize = _this$props.tabSize,\n            insertSpaces = _this$props.insertSpaces,\n            ignoreTabKey = _this$props.ignoreTabKey,\n            onKeyDown = _this$props.onKeyDown;\n\n      if (onKeyDown) {\n        onKeyDown(e);\n\n        if (e.defaultPrevented) {\n          return;\n        }\n      }\n\n      if (e.keyCode === KEYCODE_ESCAPE) {\n        e.target.blur();\n      }\n\n      const _e$target = e.target,\n            value = _e$target.value,\n            selectionStart = _e$target.selectionStart,\n            selectionEnd = _e$target.selectionEnd;\n      const tabCharacter = (insertSpaces ? \" \" : \"\\t\").repeat(tabSize);\n\n      if (e.keyCode === KEYCODE_TAB && !ignoreTabKey && this.state.capture) {\n        // Prevent focus change\n        e.preventDefault();\n\n        if (e.shiftKey) {\n          // Unindent selected lines\n          const linesBeforeCaret = this._getLines(value, selectionStart);\n\n          const startLine = linesBeforeCaret.length - 1;\n          const endLine = this._getLines(value, selectionEnd).length - 1;\n          const nextValue = value.split(\"\\n\").map((line, i) => {\n            if (i >= startLine && i <= endLine && line.startsWith(tabCharacter)) {\n              return line.substring(tabCharacter.length);\n            }\n\n            return line;\n          }).join(\"\\n\");\n\n          if (value !== nextValue) {\n            const startLineText = linesBeforeCaret[startLine];\n\n            this._applyEdits({\n              value: nextValue,\n              // Move the start cursor if first line in selection was modified\n              // It was modified only if it started with a tab\n              selectionStart: startLineText.startsWith(tabCharacter) ? selectionStart - tabCharacter.length : selectionStart,\n              // Move the end cursor by total number of characters removed\n              selectionEnd: selectionEnd - (value.length - nextValue.length)\n            });\n          }\n        } else if (selectionStart !== selectionEnd) {\n          // Indent selected lines\n          const linesBeforeCaret = this._getLines(value, selectionStart);\n\n          const startLine = linesBeforeCaret.length - 1;\n          const endLine = this._getLines(value, selectionEnd).length - 1;\n          const startLineText = linesBeforeCaret[startLine];\n\n          this._applyEdits({\n            value: value.split(\"\\n\").map((line, i) => {\n              if (i >= startLine && i <= endLine) {\n                return tabCharacter + line;\n              }\n\n              return line;\n            }).join(\"\\n\"),\n            // Move the start cursor by number of characters added in first line of selection\n            // Don't move it if it there was no text before cursor\n            selectionStart: /\\S/.test(startLineText) ? selectionStart + tabCharacter.length : selectionStart,\n            // Move the end cursor by total number of characters added\n            selectionEnd: selectionEnd + tabCharacter.length * (endLine - startLine + 1)\n          });\n        } else {\n          const updatedSelection = selectionStart + tabCharacter.length;\n\n          this._applyEdits({\n            // Insert tab character at caret\n            value: value.substring(0, selectionStart) + tabCharacter + value.substring(selectionEnd),\n            // Update caret position\n            selectionStart: updatedSelection,\n            selectionEnd: updatedSelection\n          });\n        }\n      } else if (e.keyCode === KEYCODE_BACKSPACE) {\n        const hasSelection = selectionStart !== selectionEnd;\n        const textBeforeCaret = value.substring(0, selectionStart);\n\n        if (textBeforeCaret.endsWith(tabCharacter) && !hasSelection) {\n          // Prevent default delete behaviour\n          e.preventDefault();\n          const updatedSelection = selectionStart - tabCharacter.length;\n\n          this._applyEdits({\n            // Remove tab character at caret\n            value: value.substring(0, selectionStart - tabCharacter.length) + value.substring(selectionEnd),\n            // Update caret position\n            selectionStart: updatedSelection,\n            selectionEnd: updatedSelection\n          });\n        }\n      } else if (e.keyCode === KEYCODE_ENTER) {\n        // Ignore selections\n        if (selectionStart === selectionEnd) {\n          // Get the current line\n          const line = this._getLines(value, selectionStart).pop();\n\n          const matches = line.match(/^\\s+/);\n\n          if (matches && matches[0]) {\n            e.preventDefault(); // Preserve indentation on inserting a new line\n\n            const indent = \"\\n\" + matches[0];\n            const updatedSelection = selectionStart + indent.length;\n\n            this._applyEdits({\n              // Insert indentation character at caret\n              value: value.substring(0, selectionStart) + indent + value.substring(selectionEnd),\n              // Update caret position\n              selectionStart: updatedSelection,\n              selectionEnd: updatedSelection\n            });\n          }\n        }\n      } else if (e.keyCode === KEYCODE_PARENS || e.keyCode === KEYCODE_BRACKETS || e.keyCode === KEYCODE_QUOTE || e.keyCode === KEYCODE_BACK_QUOTE) {\n        let chars;\n\n        if (e.keyCode === KEYCODE_PARENS && e.shiftKey) {\n          chars = [\"(\", \")\"];\n        } else if (e.keyCode === KEYCODE_BRACKETS) {\n          if (e.shiftKey) {\n            chars = [\"{\", \"}\"];\n          } else {\n            chars = [\"[\", \"]\"];\n          }\n        } else if (e.keyCode === KEYCODE_QUOTE) {\n          if (e.shiftKey) {\n            chars = ['\"', '\"'];\n          } else {\n            chars = [\"'\", \"'\"];\n          }\n        } else if (e.keyCode === KEYCODE_BACK_QUOTE && !e.shiftKey) {\n          chars = [\"`\", \"`\"];\n        } // If text is selected, wrap them in the characters\n\n\n        if (selectionStart !== selectionEnd && chars) {\n          e.preventDefault();\n\n          this._applyEdits({\n            value: value.substring(0, selectionStart) + chars[0] + value.substring(selectionStart, selectionEnd) + chars[1] + value.substring(selectionEnd),\n            // Update caret position\n            selectionStart,\n            selectionEnd: selectionEnd + 2\n          });\n        }\n      } else if ((isMacLike ? // Trigger undo with ⌘+Z on Mac\n      e.metaKey && e.keyCode === KEYCODE_Z : // Trigger undo with Ctrl+Z on other platforms\n      e.ctrlKey && e.keyCode === KEYCODE_Z) && !e.shiftKey && !e.altKey) {\n        e.preventDefault();\n\n        this._undoEdit();\n      } else if ((isMacLike ? // Trigger redo with ⌘+Shift+Z on Mac\n      e.metaKey && e.keyCode === KEYCODE_Z && e.shiftKey : isWindows ? // Trigger redo with Ctrl+Y on Windows\n      e.ctrlKey && e.keyCode === KEYCODE_Y : // Trigger redo with Ctrl+Shift+Z on other platforms\n      e.ctrlKey && e.keyCode === KEYCODE_Z && e.shiftKey) && !e.altKey) {\n        e.preventDefault();\n\n        this._redoEdit();\n      } else if (e.keyCode === KEYCODE_M && e.ctrlKey && (isMacLike ? e.shiftKey : true)) {\n        e.preventDefault(); // Toggle capturing tab key so users can focus away\n\n        this.setState(state => ({\n          capture: !state.capture\n        }));\n      }\n    };\n\n    this._handleChange = e => {\n      const _e$target2 = e.target,\n            value = _e$target2.value,\n            selectionStart = _e$target2.selectionStart,\n            selectionEnd = _e$target2.selectionEnd;\n\n      this._recordChange({\n        value,\n        selectionStart,\n        selectionEnd\n      }, true);\n\n      this.props.onValueChange(value);\n    };\n\n    this._history = {\n      stack: [],\n      offset: -1\n    };\n  }\n\n  componentDidMount() {\n    this._recordCurrentState();\n  }\n\n  get session() {\n    return {\n      history: this._history\n    };\n  }\n\n  set session(session) {\n    this._history = session.history;\n  }\n\n  render() {\n    const _this$props2 = this.props,\n          value = _this$props2.value,\n          style = _this$props2.style,\n          padding = _this$props2.padding,\n          highlight = _this$props2.highlight,\n          textareaId = _this$props2.textareaId,\n          autoFocus = _this$props2.autoFocus,\n          disabled = _this$props2.disabled,\n          form = _this$props2.form,\n          maxLength = _this$props2.maxLength,\n          minLength = _this$props2.minLength,\n          name = _this$props2.name,\n          placeholder = _this$props2.placeholder,\n          readOnly = _this$props2.readOnly,\n          required = _this$props2.required,\n          onClick = _this$props2.onClick,\n          onFocus = _this$props2.onFocus,\n          onBlur = _this$props2.onBlur,\n          onKeyUp = _this$props2.onKeyUp,\n          onKeyDown = _this$props2.onKeyDown,\n          onValueChange = _this$props2.onValueChange,\n          tabSize = _this$props2.tabSize,\n          insertSpaces = _this$props2.insertSpaces,\n          ignoreTabKey = _this$props2.ignoreTabKey,\n          rest = _objectWithoutProperties(_this$props2, [\"value\", \"style\", \"padding\", \"highlight\", \"textareaId\", \"autoFocus\", \"disabled\", \"form\", \"maxLength\", \"minLength\", \"name\", \"placeholder\", \"readOnly\", \"required\", \"onClick\", \"onFocus\", \"onBlur\", \"onKeyUp\", \"onKeyDown\", \"onValueChange\", \"tabSize\", \"insertSpaces\", \"ignoreTabKey\"]);\n\n    const contentStyle = {\n      paddingTop: padding,\n      paddingRight: padding,\n      paddingBottom: padding,\n      paddingLeft: padding\n    };\n    const highlighted = highlight(value);\n    return React.createElement(\"div\", Object.assign({}, rest, {\n      style: _objectSpread({}, styles.container, {}, style),\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 542\n      },\n      __self: this\n    }), React.createElement(\"textarea\", {\n      ref: c => this._input = c,\n      style: _objectSpread({}, styles.editor, {}, styles.textarea, {}, contentStyle),\n      className: className,\n      id: textareaId,\n      value: value,\n      onChange: this._handleChange,\n      onKeyDown: this._handleKeyDown,\n      onClick: onClick,\n      onKeyUp: onKeyUp,\n      onFocus: onFocus,\n      onBlur: onBlur,\n      disabled: disabled,\n      form: form,\n      maxLength: maxLength,\n      minLength: minLength,\n      name: name,\n      placeholder: placeholder,\n      readOnly: readOnly,\n      required: required,\n      autoFocus: autoFocus,\n      autoCapitalize: \"off\",\n      autoComplete: \"off\",\n      autoCorrect: \"off\",\n      spellCheck: false,\n      \"data-gramm\": false,\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 543\n      },\n      __self: this\n    }), React.createElement(\"pre\", Object.assign({\n      // aria-hidden=\"true\"\n      style: _objectSpread({}, styles.editor, {}, styles.highlight, {}, contentStyle)\n    }, typeof highlighted === \"string\" ? {\n      dangerouslySetInnerHTML: {\n        __html: highlighted + \"<br />\"\n      }\n    } : {\n      children: highlighted\n    }, {\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 574\n      },\n      __self: this\n    })), React.createElement(\"style\", {\n      type: \"text/css\",\n      dangerouslySetInnerHTML: {\n        __html: cssText\n      },\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 582\n      },\n      __self: this\n    }));\n  }\n\n}\nEditor.defaultProps = {\n  tabSize: 2,\n  insertSpaces: true,\n  ignoreTabKey: false,\n  padding: 0\n};\nconst styles = {\n  container: {\n    position: \"relative\",\n    textAlign: \"left\",\n    boxSizing: \"border-box\",\n    padding: 0,\n    overflow: \"hidden\"\n  },\n  textarea: {\n    position: \"absolute\",\n    top: 0,\n    left: 0,\n    height: \"100%\",\n    width: \"100%\",\n    resize: \"none\",\n    color: \"inherit\",\n    overflow: \"hidden\",\n    MozOsxFontSmoothing: \"grayscale\",\n    WebkitFontSmoothing: \"antialiased\",\n    WebkitTextFillColor: \"transparent\"\n  },\n  highlight: {\n    position: \"relative\",\n    pointerEvents: \"none\"\n  },\n  editor: {\n    margin: 0,\n    border: 0,\n    background: \"none\",\n    boxSizing: \"inherit\",\n    display: \"inherit\",\n    fontFamily: \"inherit\",\n    fontSize: \"inherit\",\n    fontStyle: \"inherit\",\n    fontVariantLigatures: \"inherit\",\n    fontWeight: \"inherit\",\n    letterSpacing: \"inherit\",\n    lineHeight: \"inherit\",\n    tabSize: \"inherit\",\n    textIndent: \"inherit\",\n    textRendering: \"inherit\",\n    textTransform: \"inherit\",\n    whiteSpace: \"pre-wrap\",\n    wordBreak: \"keep-all\",\n    overflowWrap: \"break-word\"\n  }\n};","map":{"version":3,"sources":["/Users/guokai/Desktop/React-connect/src/Editor/index.js"],"names":["React","KEYCODE_ENTER","KEYCODE_TAB","KEYCODE_BACKSPACE","KEYCODE_Y","KEYCODE_Z","KEYCODE_M","KEYCODE_PARENS","KEYCODE_BRACKETS","KEYCODE_QUOTE","KEYCODE_BACK_QUOTE","KEYCODE_ESCAPE","HISTORY_LIMIT","HISTORY_TIME_GAP","isWindows","global","test","navigator","platform","isMacLike","className","cssText","Editor","Component","state","capture","_recordCurrentState","input","_input","value","selectionStart","selectionEnd","_recordChange","_getLines","text","position","substring","split","record","overwrite","_history","stack","offset","length","slice","count","extras","Math","max","timestamp","Date","now","last","re","previous","pop","match","current","startsWith","push","_updateInput","props","onValueChange","_applyEdits","_undoEdit","_redoEdit","min","_handleKeyDown","e","tabSize","insertSpaces","ignoreTabKey","onKeyDown","defaultPrevented","keyCode","target","blur","tabCharacter","repeat","preventDefault","shiftKey","linesBeforeCaret","startLine","endLine","nextValue","map","line","i","join","startLineText","updatedSelection","hasSelection","textBeforeCaret","endsWith","matches","indent","chars","metaKey","ctrlKey","altKey","setState","_handleChange","componentDidMount","session","history","render","style","padding","highlight","textareaId","autoFocus","disabled","form","maxLength","minLength","name","placeholder","readOnly","required","onClick","onFocus","onBlur","onKeyUp","rest","contentStyle","paddingTop","paddingRight","paddingBottom","paddingLeft","highlighted","styles","container","c","editor","textarea","dangerouslySetInnerHTML","__html","children","defaultProps","textAlign","boxSizing","overflow","top","left","height","width","resize","color","MozOsxFontSmoothing","WebkitFontSmoothing","WebkitTextFillColor","pointerEvents","margin","border","background","display","fontFamily","fontSize","fontStyle","fontVariantLigatures","fontWeight","letterSpacing","lineHeight","textIndent","textRendering","textTransform","whiteSpace","wordBreak","overflowWrap"],"mappings":";;;;AACA;AAEA,OAAO,KAAKA,KAAZ,MAAuB,OAAvB;AA8CA,MAAMC,aAAa,GAAG,EAAtB;AACA,MAAMC,WAAW,GAAG,CAApB;AACA,MAAMC,iBAAiB,GAAG,CAA1B;AACA,MAAMC,SAAS,GAAG,EAAlB;AACA,MAAMC,SAAS,GAAG,EAAlB;AACA,MAAMC,SAAS,GAAG,EAAlB;AACA,MAAMC,cAAc,GAAG,EAAvB;AACA,MAAMC,gBAAgB,GAAG,GAAzB;AACA,MAAMC,aAAa,GAAG,GAAtB;AACA,MAAMC,kBAAkB,GAAG,GAA3B;AACA,MAAMC,cAAc,GAAG,EAAvB;AAEA,MAAMC,aAAa,GAAG,GAAtB;AACA,MAAMC,gBAAgB,GAAG,IAAzB;AAEA,MAAMC,SAAS,GAAG,eAAeC,MAAf,IAAyB,OAAOC,IAAP,CAAYC,SAAS,CAACC,QAAtB,CAA3C;AACA,MAAMC,SAAS,GACb,eAAeJ,MAAf,IAAyB,0BAA0BC,IAA1B,CAA+BC,SAAS,CAACC,QAAzC,CAD3B;AAGA,MAAME,SAAS,GAAG,yCAAlB;AAEA,MAAMC,OAAO;AAAG;AAAW;;;;GAIxBD,SAAU;;;;;;;;;;;;;KAaRA,SAAU;;;;KAIVA,SAAU;;;;;CArBf;AA4BA,eAAe,MAAME,MAAN,SAAqBtB,KAAK,CAACuB,SAA3B,CAAmD;AAAA;AAAA;AAAA,SAQhEC,KARgE,GAQxD;AACNC,MAAAA,OAAO,EAAE;AADH,KARwD;;AAAA,SAgBhEC,mBAhBgE,GAgB1C,MAAM;AAC1B,YAAMC,KAAK,GAAG,KAAKC,MAAnB;AAEA,UAAI,CAACD,KAAL,EAAY,OAHc,CAK1B;;AAL0B,YAMlBE,KANkB,GAMsBF,KANtB,CAMlBE,KANkB;AAAA,YAMXC,cANW,GAMsBH,KANtB,CAMXG,cANW;AAAA,YAMKC,YANL,GAMsBJ,KANtB,CAMKI,YANL;;AAQ1B,WAAKC,aAAL,CAAmB;AACjBH,QAAAA,KADiB;AAEjBC,QAAAA,cAFiB;AAGjBC,QAAAA;AAHiB,OAAnB;AAKD,KA7B+D;;AAAA,SA+BhEE,SA/BgE,GA+BpD,CAACC,IAAD,EAAeC,QAAf,KACVD,IAAI,CAACE,SAAL,CAAe,CAAf,EAAkBD,QAAlB,EAA4BE,KAA5B,CAAkC,IAAlC,CAhC8D;;AAAA,SAkChEL,aAlCgE,GAkChD,CAACM,MAAD,EAAiBC,SAAmB,GAAG,KAAvC,KAAiD;AAAA,6BACrC,KAAKC,QADgC;AAAA,YACvDC,KADuD,kBACvDA,KADuD;AAAA,YAChDC,MADgD,kBAChDA,MADgD;;AAG/D,UAAID,KAAK,CAACE,MAAN,IAAgBD,MAAM,GAAG,CAAC,CAA9B,EAAiC;AAC/B;AACA,aAAKF,QAAL,CAAcC,KAAd,GAAsBA,KAAK,CAACG,KAAN,CAAY,CAAZ,EAAeF,MAAM,GAAG,CAAxB,CAAtB,CAF+B,CAI/B;;AACA,cAAMG,KAAK,GAAG,KAAKL,QAAL,CAAcC,KAAd,CAAoBE,MAAlC;;AAEA,YAAIE,KAAK,GAAGjC,aAAZ,EAA2B;AACzB,gBAAMkC,MAAM,GAAGD,KAAK,GAAGjC,aAAvB;AAEA,eAAK4B,QAAL,CAAcC,KAAd,GAAsBA,KAAK,CAACG,KAAN,CAAYE,MAAZ,EAAoBD,KAApB,CAAtB;AACA,eAAKL,QAAL,CAAcE,MAAd,GAAuBK,IAAI,CAACC,GAAL,CAAS,KAAKR,QAAL,CAAcE,MAAd,GAAuBI,MAAhC,EAAwC,CAAxC,CAAvB;AACD;AACF;;AAED,YAAMG,SAAS,GAAGC,IAAI,CAACC,GAAL,EAAlB;;AAEA,UAAIZ,SAAJ,EAAe;AACb,cAAMa,IAAI,GAAG,KAAKZ,QAAL,CAAcC,KAAd,CAAoB,KAAKD,QAAL,CAAcE,MAAlC,CAAb;;AAEA,YAAIU,IAAI,IAAIH,SAAS,GAAGG,IAAI,CAACH,SAAjB,GAA6BpC,gBAAzC,EAA2D;AACzD;AAEA;AACA,gBAAMwC,EAAE,GAAG,wBAAX,CAJyD,CAMzD;;AACA,gBAAMC,QAAQ,GAAG,KAAKrB,SAAL,CAAemB,IAAI,CAACvB,KAApB,EAA2BuB,IAAI,CAACtB,cAAhC,EACdyB,GADc,GAEdC,KAFc,CAERH,EAFQ,CAAjB,CAPyD,CAWzD;;;AACA,gBAAMI,OAAO,GAAG,KAAKxB,SAAL,CAAeK,MAAM,CAACT,KAAtB,EAA6BS,MAAM,CAACR,cAApC,EACbyB,GADa,GAEbC,KAFa,CAEPH,EAFO,CAAhB;;AAIA,cAAIC,QAAQ,IAAIG,OAAZ,IAAuBA,OAAO,CAAC,CAAD,CAAP,CAAWC,UAAX,CAAsBJ,QAAQ,CAAC,CAAD,CAA9B,CAA3B,EAA+D;AAC7D;AACA;AACA,iBAAKd,QAAL,CAAcC,KAAd,CAAoB,KAAKD,QAAL,CAAcE,MAAlC,sBAAiDJ,MAAjD;AAAyDW,cAAAA;AAAzD;AAEA;AACD;AACF;AACF,OA/C8D,CAiD/D;;;AACA,WAAKT,QAAL,CAAcC,KAAd,CAAoBkB,IAApB,mBAA8BrB,MAA9B;AAAsCW,QAAAA;AAAtC;;AACA,WAAKT,QAAL,CAAcE,MAAd;AACD,KAtF+D;;AAAA,SAwFhEkB,YAxFgE,GAwFhDtB,MAAD,IAAoB;AACjC,YAAMX,KAAK,GAAG,KAAKC,MAAnB;AAEA,UAAI,CAACD,KAAL,EAAY,OAHqB,CAKjC;;AACAA,MAAAA,KAAK,CAACE,KAAN,GAAcS,MAAM,CAACT,KAArB;AACAF,MAAAA,KAAK,CAACG,cAAN,GAAuBQ,MAAM,CAACR,cAA9B;AACAH,MAAAA,KAAK,CAACI,YAAN,GAAqBO,MAAM,CAACP,YAA5B;AAEA,WAAK8B,KAAL,CAAWC,aAAX,CAAyBxB,MAAM,CAACT,KAAhC;AACD,KAnG+D;;AAAA,SAqGhEkC,WArGgE,GAqGjDzB,MAAD,IAAoB;AAChC;AACA,YAAMX,KAAK,GAAG,KAAKC,MAAnB;AACA,YAAMwB,IAAI,GAAG,KAAKZ,QAAL,CAAcC,KAAd,CAAoB,KAAKD,QAAL,CAAcE,MAAlC,CAAb;;AAEA,UAAIU,IAAI,IAAIzB,KAAZ,EAAmB;AACjB,aAAKa,QAAL,CAAcC,KAAd,CAAoB,KAAKD,QAAL,CAAcE,MAAlC,sBACKU,IADL;AAEEtB,UAAAA,cAAc,EAAEH,KAAK,CAACG,cAFxB;AAGEC,UAAAA,YAAY,EAAEJ,KAAK,CAACI;AAHtB;AAKD,OAX+B,CAahC;;;AACA,WAAKC,aAAL,CAAmBM,MAAnB;;AACA,WAAKsB,YAAL,CAAkBtB,MAAlB;AACD,KArH+D;;AAAA,SAuHhE0B,SAvHgE,GAuHpD,MAAM;AAAA,8BACU,KAAKxB,QADf;AAAA,YACRC,KADQ,mBACRA,KADQ;AAAA,YACDC,MADC,mBACDA,MADC,EAGhB;;AACA,YAAMJ,MAAM,GAAGG,KAAK,CAACC,MAAM,GAAG,CAAV,CAApB;;AAEA,UAAIJ,MAAJ,EAAY;AACV;AACA,aAAKsB,YAAL,CAAkBtB,MAAlB;;AACA,aAAKE,QAAL,CAAcE,MAAd,GAAuBK,IAAI,CAACC,GAAL,CAASN,MAAM,GAAG,CAAlB,EAAqB,CAArB,CAAvB;AACD;AACF,KAlI+D;;AAAA,SAoIhEuB,SApIgE,GAoIpD,MAAM;AAAA,8BACU,KAAKzB,QADf;AAAA,YACRC,KADQ,mBACRA,KADQ;AAAA,YACDC,MADC,mBACDA,MADC,EAGhB;;AACA,YAAMJ,MAAM,GAAGG,KAAK,CAACC,MAAM,GAAG,CAAV,CAApB;;AAEA,UAAIJ,MAAJ,EAAY;AACV;AACA,aAAKsB,YAAL,CAAkBtB,MAAlB;;AACA,aAAKE,QAAL,CAAcE,MAAd,GAAuBK,IAAI,CAACmB,GAAL,CAASxB,MAAM,GAAG,CAAlB,EAAqBD,KAAK,CAACE,MAAN,GAAe,CAApC,CAAvB;AACD;AACF,KA/I+D;;AAAA,SAiJhEwB,cAjJgE,GAiJ9CC,CAAD,IAAU;AAAA,0BACkC,KAAKP,KADvC;AAAA,YACjBQ,OADiB,eACjBA,OADiB;AAAA,YACRC,YADQ,eACRA,YADQ;AAAA,YACMC,YADN,eACMA,YADN;AAAA,YACoBC,SADpB,eACoBA,SADpB;;AAGzB,UAAIA,SAAJ,EAAe;AACbA,QAAAA,SAAS,CAACJ,CAAD,CAAT;;AAEA,YAAIA,CAAC,CAACK,gBAAN,EAAwB;AACtB;AACD;AACF;;AAED,UAAIL,CAAC,CAACM,OAAF,KAAc/D,cAAlB,EAAkC;AAChCyD,QAAAA,CAAC,CAACO,MAAF,CAASC,IAAT;AACD;;AAbwB,wBAeuBR,CAAC,CAACO,MAfzB;AAAA,YAejB9C,KAfiB,aAejBA,KAfiB;AAAA,YAeVC,cAfU,aAeVA,cAfU;AAAA,YAeMC,YAfN,aAeMA,YAfN;AAiBzB,YAAM8C,YAAY,GAAG,CAACP,YAAY,GAAG,GAAH,GAAS,IAAtB,EAA4BQ,MAA5B,CAAmCT,OAAnC,CAArB;;AAEA,UAAID,CAAC,CAACM,OAAF,KAAcxE,WAAd,IAA6B,CAACqE,YAA9B,IAA8C,KAAK/C,KAAL,CAAWC,OAA7D,EAAsE;AACpE;AACA2C,QAAAA,CAAC,CAACW,cAAF;;AAEA,YAAIX,CAAC,CAACY,QAAN,EAAgB;AACd;AACA,gBAAMC,gBAAgB,GAAG,KAAKhD,SAAL,CAAeJ,KAAf,EAAsBC,cAAtB,CAAzB;;AACA,gBAAMoD,SAAS,GAAGD,gBAAgB,CAACtC,MAAjB,GAA0B,CAA5C;AACA,gBAAMwC,OAAO,GAAG,KAAKlD,SAAL,CAAeJ,KAAf,EAAsBE,YAAtB,EAAoCY,MAApC,GAA6C,CAA7D;AACA,gBAAMyC,SAAS,GAAGvD,KAAK,CACpBQ,KADe,CACT,IADS,EAEfgD,GAFe,CAEX,CAACC,IAAD,EAAOC,CAAP,KAAa;AAChB,gBACEA,CAAC,IAAIL,SAAL,IACAK,CAAC,IAAIJ,OADL,IAEAG,IAAI,CAAC5B,UAAL,CAAgBmB,YAAhB,CAHF,EAIE;AACA,qBAAOS,IAAI,CAAClD,SAAL,CAAeyC,YAAY,CAAClC,MAA5B,CAAP;AACD;;AAED,mBAAO2C,IAAP;AACD,WAZe,EAafE,IAbe,CAaV,IAbU,CAAlB;;AAeA,cAAI3D,KAAK,KAAKuD,SAAd,EAAyB;AACvB,kBAAMK,aAAa,GAAGR,gBAAgB,CAACC,SAAD,CAAtC;;AAEA,iBAAKnB,WAAL,CAAiB;AACflC,cAAAA,KAAK,EAAEuD,SADQ;AAEf;AACA;AACAtD,cAAAA,cAAc,EAAE2D,aAAa,CAAC/B,UAAd,CAAyBmB,YAAzB,IACZ/C,cAAc,GAAG+C,YAAY,CAAClC,MADlB,GAEZb,cANW;AAOf;AACAC,cAAAA,YAAY,EAAEA,YAAY,IAAIF,KAAK,CAACc,MAAN,GAAeyC,SAAS,CAACzC,MAA7B;AARX,aAAjB;AAUD;AACF,SAlCD,MAkCO,IAAIb,cAAc,KAAKC,YAAvB,EAAqC;AAC1C;AACA,gBAAMkD,gBAAgB,GAAG,KAAKhD,SAAL,CAAeJ,KAAf,EAAsBC,cAAtB,CAAzB;;AACA,gBAAMoD,SAAS,GAAGD,gBAAgB,CAACtC,MAAjB,GAA0B,CAA5C;AACA,gBAAMwC,OAAO,GAAG,KAAKlD,SAAL,CAAeJ,KAAf,EAAsBE,YAAtB,EAAoCY,MAApC,GAA6C,CAA7D;AACA,gBAAM8C,aAAa,GAAGR,gBAAgB,CAACC,SAAD,CAAtC;;AAEA,eAAKnB,WAAL,CAAiB;AACflC,YAAAA,KAAK,EAAEA,KAAK,CACTQ,KADI,CACE,IADF,EAEJgD,GAFI,CAEA,CAACC,IAAD,EAAOC,CAAP,KAAa;AAChB,kBAAIA,CAAC,IAAIL,SAAL,IAAkBK,CAAC,IAAIJ,OAA3B,EAAoC;AAClC,uBAAON,YAAY,GAAGS,IAAtB;AACD;;AAED,qBAAOA,IAAP;AACD,aARI,EASJE,IATI,CASC,IATD,CADQ;AAWf;AACA;AACA1D,YAAAA,cAAc,EAAE,KAAKd,IAAL,CAAUyE,aAAV,IACZ3D,cAAc,GAAG+C,YAAY,CAAClC,MADlB,GAEZb,cAfW;AAgBf;AACAC,YAAAA,YAAY,EACVA,YAAY,GAAG8C,YAAY,CAAClC,MAAb,IAAuBwC,OAAO,GAAGD,SAAV,GAAsB,CAA7C;AAlBF,WAAjB;AAoBD,SA3BM,MA2BA;AACL,gBAAMQ,gBAAgB,GAAG5D,cAAc,GAAG+C,YAAY,CAAClC,MAAvD;;AAEA,eAAKoB,WAAL,CAAiB;AACf;AACAlC,YAAAA,KAAK,EACHA,KAAK,CAACO,SAAN,CAAgB,CAAhB,EAAmBN,cAAnB,IACA+C,YADA,GAEAhD,KAAK,CAACO,SAAN,CAAgBL,YAAhB,CALa;AAMf;AACAD,YAAAA,cAAc,EAAE4D,gBAPD;AAQf3D,YAAAA,YAAY,EAAE2D;AARC,WAAjB;AAUD;AACF,OA/ED,MA+EO,IAAItB,CAAC,CAACM,OAAF,KAAcvE,iBAAlB,EAAqC;AAC1C,cAAMwF,YAAY,GAAG7D,cAAc,KAAKC,YAAxC;AACA,cAAM6D,eAAe,GAAG/D,KAAK,CAACO,SAAN,CAAgB,CAAhB,EAAmBN,cAAnB,CAAxB;;AAEA,YAAI8D,eAAe,CAACC,QAAhB,CAAyBhB,YAAzB,KAA0C,CAACc,YAA/C,EAA6D;AAC3D;AACAvB,UAAAA,CAAC,CAACW,cAAF;AAEA,gBAAMW,gBAAgB,GAAG5D,cAAc,GAAG+C,YAAY,CAAClC,MAAvD;;AAEA,eAAKoB,WAAL,CAAiB;AACf;AACAlC,YAAAA,KAAK,EACHA,KAAK,CAACO,SAAN,CAAgB,CAAhB,EAAmBN,cAAc,GAAG+C,YAAY,CAAClC,MAAjD,IACAd,KAAK,CAACO,SAAN,CAAgBL,YAAhB,CAJa;AAKf;AACAD,YAAAA,cAAc,EAAE4D,gBAND;AAOf3D,YAAAA,YAAY,EAAE2D;AAPC,WAAjB;AASD;AACF,OApBM,MAoBA,IAAItB,CAAC,CAACM,OAAF,KAAczE,aAAlB,EAAiC;AACtC;AACA,YAAI6B,cAAc,KAAKC,YAAvB,EAAqC;AACnC;AACA,gBAAMuD,IAAI,GAAG,KAAKrD,SAAL,CAAeJ,KAAf,EAAsBC,cAAtB,EAAsCyB,GAAtC,EAAb;;AACA,gBAAMuC,OAAO,GAAGR,IAAI,CAAC9B,KAAL,CAAW,MAAX,CAAhB;;AAEA,cAAIsC,OAAO,IAAIA,OAAO,CAAC,CAAD,CAAtB,EAA2B;AACzB1B,YAAAA,CAAC,CAACW,cAAF,GADyB,CAGzB;;AACA,kBAAMgB,MAAM,GAAG,OAAOD,OAAO,CAAC,CAAD,CAA7B;AACA,kBAAMJ,gBAAgB,GAAG5D,cAAc,GAAGiE,MAAM,CAACpD,MAAjD;;AAEA,iBAAKoB,WAAL,CAAiB;AACf;AACAlC,cAAAA,KAAK,EACHA,KAAK,CAACO,SAAN,CAAgB,CAAhB,EAAmBN,cAAnB,IACAiE,MADA,GAEAlE,KAAK,CAACO,SAAN,CAAgBL,YAAhB,CALa;AAMf;AACAD,cAAAA,cAAc,EAAE4D,gBAPD;AAQf3D,cAAAA,YAAY,EAAE2D;AARC,aAAjB;AAUD;AACF;AACF,OA1BM,MA0BA,IACLtB,CAAC,CAACM,OAAF,KAAcnE,cAAd,IACA6D,CAAC,CAACM,OAAF,KAAclE,gBADd,IAEA4D,CAAC,CAACM,OAAF,KAAcjE,aAFd,IAGA2D,CAAC,CAACM,OAAF,KAAchE,kBAJT,EAKL;AACA,YAAIsF,KAAJ;;AAEA,YAAI5B,CAAC,CAACM,OAAF,KAAcnE,cAAd,IAAgC6D,CAAC,CAACY,QAAtC,EAAgD;AAC9CgB,UAAAA,KAAK,GAAG,CAAC,GAAD,EAAM,GAAN,CAAR;AACD,SAFD,MAEO,IAAI5B,CAAC,CAACM,OAAF,KAAclE,gBAAlB,EAAoC;AACzC,cAAI4D,CAAC,CAACY,QAAN,EAAgB;AACdgB,YAAAA,KAAK,GAAG,CAAC,GAAD,EAAM,GAAN,CAAR;AACD,WAFD,MAEO;AACLA,YAAAA,KAAK,GAAG,CAAC,GAAD,EAAM,GAAN,CAAR;AACD;AACF,SANM,MAMA,IAAI5B,CAAC,CAACM,OAAF,KAAcjE,aAAlB,EAAiC;AACtC,cAAI2D,CAAC,CAACY,QAAN,EAAgB;AACdgB,YAAAA,KAAK,GAAG,CAAC,GAAD,EAAM,GAAN,CAAR;AACD,WAFD,MAEO;AACLA,YAAAA,KAAK,GAAG,CAAC,GAAD,EAAM,GAAN,CAAR;AACD;AACF,SANM,MAMA,IAAI5B,CAAC,CAACM,OAAF,KAAchE,kBAAd,IAAoC,CAAC0D,CAAC,CAACY,QAA3C,EAAqD;AAC1DgB,UAAAA,KAAK,GAAG,CAAC,GAAD,EAAM,GAAN,CAAR;AACD,SAnBD,CAqBA;;;AACA,YAAIlE,cAAc,KAAKC,YAAnB,IAAmCiE,KAAvC,EAA8C;AAC5C5B,UAAAA,CAAC,CAACW,cAAF;;AAEA,eAAKhB,WAAL,CAAiB;AACflC,YAAAA,KAAK,EACHA,KAAK,CAACO,SAAN,CAAgB,CAAhB,EAAmBN,cAAnB,IACAkE,KAAK,CAAC,CAAD,CADL,GAEAnE,KAAK,CAACO,SAAN,CAAgBN,cAAhB,EAAgCC,YAAhC,CAFA,GAGAiE,KAAK,CAAC,CAAD,CAHL,GAIAnE,KAAK,CAACO,SAAN,CAAgBL,YAAhB,CANa;AAOf;AACAD,YAAAA,cARe;AASfC,YAAAA,YAAY,EAAEA,YAAY,GAAG;AATd,WAAjB;AAWD;AACF,OA1CM,MA0CA,IACL,CAACZ,SAAS,GACN;AACAiD,MAAAA,CAAC,CAAC6B,OAAF,IAAa7B,CAAC,CAACM,OAAF,KAAcrE,SAFrB,GAGN;AACA+D,MAAAA,CAAC,CAAC8B,OAAF,IAAa9B,CAAC,CAACM,OAAF,KAAcrE,SAJ/B,KAKA,CAAC+D,CAAC,CAACY,QALH,IAMA,CAACZ,CAAC,CAAC+B,MAPE,EAQL;AACA/B,QAAAA,CAAC,CAACW,cAAF;;AAEA,aAAKf,SAAL;AACD,OAZM,MAYA,IACL,CAAC7C,SAAS,GACN;AACAiD,MAAAA,CAAC,CAAC6B,OAAF,IAAa7B,CAAC,CAACM,OAAF,KAAcrE,SAA3B,IAAwC+D,CAAC,CAACY,QAFpC,GAGNlE,SAAS,GACT;AACAsD,MAAAA,CAAC,CAAC8B,OAAF,IAAa9B,CAAC,CAACM,OAAF,KAActE,SAFlB,GAGT;AACAgE,MAAAA,CAAC,CAAC8B,OAAF,IAAa9B,CAAC,CAACM,OAAF,KAAcrE,SAA3B,IAAwC+D,CAAC,CAACY,QAP9C,KAQA,CAACZ,CAAC,CAAC+B,MATE,EAUL;AACA/B,QAAAA,CAAC,CAACW,cAAF;;AAEA,aAAKd,SAAL;AACD,OAdM,MAcA,IACLG,CAAC,CAACM,OAAF,KAAcpE,SAAd,IACA8D,CAAC,CAAC8B,OADF,KAEC/E,SAAS,GAAGiD,CAAC,CAACY,QAAL,GAAgB,IAF1B,CADK,EAIL;AACAZ,QAAAA,CAAC,CAACW,cAAF,GADA,CAGA;;AACA,aAAKqB,QAAL,CAAc5E,KAAK,KAAK;AACtBC,UAAAA,OAAO,EAAE,CAACD,KAAK,CAACC;AADM,SAAL,CAAnB;AAGD;AACF,KAjX+D;;AAAA,SAmXhE4E,aAnXgE,GAmX/CjC,CAAD,IAAU;AAAA,yBACwBA,CAAC,CAACO,MAD1B;AAAA,YAChB9C,KADgB,cAChBA,KADgB;AAAA,YACTC,cADS,cACTA,cADS;AAAA,YACOC,YADP,cACOA,YADP;;AAGxB,WAAKC,aAAL,CACE;AACEH,QAAAA,KADF;AAEEC,QAAAA,cAFF;AAGEC,QAAAA;AAHF,OADF,EAME,IANF;;AASA,WAAK8B,KAAL,CAAWC,aAAX,CAAyBjC,KAAzB;AACD,KAhY+D;;AAAA,SAkYhEW,QAlYgE,GAkY5C;AAClBC,MAAAA,KAAK,EAAE,EADW;AAElBC,MAAAA,MAAM,EAAE,CAAC;AAFS,KAlY4C;AAAA;;AAYhE4D,EAAAA,iBAAiB,GAAG;AAClB,SAAK5E,mBAAL;AACD;;AA2XD,MAAI6E,OAAJ,GAAc;AACZ,WAAO;AACLC,MAAAA,OAAO,EAAE,KAAKhE;AADT,KAAP;AAGD;;AAED,MAAI+D,OAAJ,CAAYA,OAAZ,EAA2C;AACzC,SAAK/D,QAAL,GAAgB+D,OAAO,CAACC,OAAxB;AACD;;AAEDC,EAAAA,MAAM,GAAG;AAAA,yBA4BH,KAAK5C,KA5BF;AAAA,UAELhC,KAFK,gBAELA,KAFK;AAAA,UAGL6E,KAHK,gBAGLA,KAHK;AAAA,UAILC,OAJK,gBAILA,OAJK;AAAA,UAKLC,SALK,gBAKLA,SALK;AAAA,UAMLC,UANK,gBAMLA,UANK;AAAA,UAOLC,SAPK,gBAOLA,SAPK;AAAA,UAQLC,QARK,gBAQLA,QARK;AAAA,UASLC,IATK,gBASLA,IATK;AAAA,UAULC,SAVK,gBAULA,SAVK;AAAA,UAWLC,SAXK,gBAWLA,SAXK;AAAA,UAYLC,IAZK,gBAYLA,IAZK;AAAA,UAaLC,WAbK,gBAaLA,WAbK;AAAA,UAcLC,QAdK,gBAcLA,QAdK;AAAA,UAeLC,QAfK,gBAeLA,QAfK;AAAA,UAgBLC,OAhBK,gBAgBLA,OAhBK;AAAA,UAiBLC,OAjBK,gBAiBLA,OAjBK;AAAA,UAkBLC,MAlBK,gBAkBLA,MAlBK;AAAA,UAmBLC,OAnBK,gBAmBLA,OAnBK;AAAA,UAqBLlD,SArBK,gBAqBLA,SArBK;AAAA,UAsBLV,aAtBK,gBAsBLA,aAtBK;AAAA,UAuBLO,OAvBK,gBAuBLA,OAvBK;AAAA,UAwBLC,YAxBK,gBAwBLA,YAxBK;AAAA,UAyBLC,YAzBK,gBAyBLA,YAzBK;AAAA,UA2BFoD,IA3BE;;AA8BP,UAAMC,YAAY,GAAG;AACnBC,MAAAA,UAAU,EAAElB,OADO;AAEnBmB,MAAAA,YAAY,EAAEnB,OAFK;AAGnBoB,MAAAA,aAAa,EAAEpB,OAHI;AAInBqB,MAAAA,WAAW,EAAErB;AAJM,KAArB;AAOA,UAAMsB,WAAW,GAAGrB,SAAS,CAAC/E,KAAD,CAA7B;AAEA,WACE,6CAAS8F,IAAT;AAAe,MAAA,KAAK,oBAAOO,MAAM,CAACC,SAAd,MAA4BzB,KAA5B,CAApB;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,QACE;AACE,MAAA,GAAG,EAAE0B,CAAC,IAAK,KAAKxG,MAAL,GAAcwG,CAD3B;AAEE,MAAA,KAAK,oBACAF,MAAM,CAACG,MADP,MAEAH,MAAM,CAACI,QAFP,MAGAV,YAHA,CAFP;AAOE,MAAA,SAAS,EAAExG,SAPb;AAQE,MAAA,EAAE,EAAEyF,UARN;AASE,MAAA,KAAK,EAAEhF,KATT;AAUE,MAAA,QAAQ,EAAE,KAAKwE,aAVjB;AAWE,MAAA,SAAS,EAAE,KAAKlC,cAXlB;AAYE,MAAA,OAAO,EAAEoD,OAZX;AAaE,MAAA,OAAO,EAAEG,OAbX;AAcE,MAAA,OAAO,EAAEF,OAdX;AAeE,MAAA,MAAM,EAAEC,MAfV;AAgBE,MAAA,QAAQ,EAAEV,QAhBZ;AAiBE,MAAA,IAAI,EAAEC,IAjBR;AAkBE,MAAA,SAAS,EAAEC,SAlBb;AAmBE,MAAA,SAAS,EAAEC,SAnBb;AAoBE,MAAA,IAAI,EAAEC,IApBR;AAqBE,MAAA,WAAW,EAAEC,WArBf;AAsBE,MAAA,QAAQ,EAAEC,QAtBZ;AAuBE,MAAA,QAAQ,EAAEC,QAvBZ;AAwBE,MAAA,SAAS,EAAER,SAxBb;AAyBE,MAAA,cAAc,EAAC,KAzBjB;AA0BE,MAAA,YAAY,EAAC,KA1Bf;AA2BE,MAAA,WAAW,EAAC,KA3Bd;AA4BE,MAAA,UAAU,EAAE,KA5Bd;AA6BE,oBAAY,KA7Bd;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,MADF,EAgCE;AACE;AACA,MAAA,KAAK,oBAAOoB,MAAM,CAACG,MAAd,MAAyBH,MAAM,CAACtB,SAAhC,MAA8CgB,YAA9C;AAFP,OAGO,OAAOK,WAAP,KAAuB,QAAvB,GACD;AAAEM,MAAAA,uBAAuB,EAAE;AAAEC,QAAAA,MAAM,EAAEP,WAAW,GAAG;AAAxB;AAA3B,KADC,GAED;AAAEQ,MAAAA,QAAQ,EAAER;AAAZ,KALN;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,OAhCF,EAwCE;AAAO,MAAA,IAAI,EAAC,UAAZ;AAAuB,MAAA,uBAAuB,EAAE;AAAEO,QAAAA,MAAM,EAAEnH;AAAV,OAAhD;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,MAxCF,CADF;AA4CD;;AAte+D;AAA7CC,M,CACZoH,Y,GAAe;AACpBrE,EAAAA,OAAO,EAAE,CADW;AAEpBC,EAAAA,YAAY,EAAE,IAFM;AAGpBC,EAAAA,YAAY,EAAE,KAHM;AAIpBoC,EAAAA,OAAO,EAAE;AAJW,C;AAwexB,MAAMuB,MAAM,GAAG;AACbC,EAAAA,SAAS,EAAE;AACThG,IAAAA,QAAQ,EAAE,UADD;AAETwG,IAAAA,SAAS,EAAE,MAFF;AAGTC,IAAAA,SAAS,EAAE,YAHF;AAITjC,IAAAA,OAAO,EAAE,CAJA;AAKTkC,IAAAA,QAAQ,EAAE;AALD,GADE;AAQbP,EAAAA,QAAQ,EAAE;AACRnG,IAAAA,QAAQ,EAAE,UADF;AAER2G,IAAAA,GAAG,EAAE,CAFG;AAGRC,IAAAA,IAAI,EAAE,CAHE;AAIRC,IAAAA,MAAM,EAAE,MAJA;AAKRC,IAAAA,KAAK,EAAE,MALC;AAMRC,IAAAA,MAAM,EAAE,MANA;AAORC,IAAAA,KAAK,EAAE,SAPC;AAQRN,IAAAA,QAAQ,EAAE,QARF;AASRO,IAAAA,mBAAmB,EAAE,WATb;AAURC,IAAAA,mBAAmB,EAAE,aAVb;AAWRC,IAAAA,mBAAmB,EAAE;AAXb,GARG;AAqBb1C,EAAAA,SAAS,EAAE;AACTzE,IAAAA,QAAQ,EAAE,UADD;AAEToH,IAAAA,aAAa,EAAE;AAFN,GArBE;AAyBblB,EAAAA,MAAM,EAAE;AACNmB,IAAAA,MAAM,EAAE,CADF;AAENC,IAAAA,MAAM,EAAE,CAFF;AAGNC,IAAAA,UAAU,EAAE,MAHN;AAINd,IAAAA,SAAS,EAAE,SAJL;AAKNe,IAAAA,OAAO,EAAE,SALH;AAMNC,IAAAA,UAAU,EAAE,SANN;AAONC,IAAAA,QAAQ,EAAE,SAPJ;AAQNC,IAAAA,SAAS,EAAE,SARL;AASNC,IAAAA,oBAAoB,EAAE,SAThB;AAUNC,IAAAA,UAAU,EAAE,SAVN;AAWNC,IAAAA,aAAa,EAAE,SAXT;AAYNC,IAAAA,UAAU,EAAE,SAZN;AAaN7F,IAAAA,OAAO,EAAE,SAbH;AAcN8F,IAAAA,UAAU,EAAE,SAdN;AAeNC,IAAAA,aAAa,EAAE,SAfT;AAgBNC,IAAAA,aAAa,EAAE,SAhBT;AAiBNC,IAAAA,UAAU,EAAE,UAjBN;AAkBNC,IAAAA,SAAS,EAAE,UAlBL;AAmBNC,IAAAA,YAAY,EAAE;AAnBR;AAzBK,CAAf","sourcesContent":["/* @flow */\n/* global global */\n\nimport * as React from \"react\";\n\ntype Props = React.ElementConfig<\"div\"> & {\n  // Props for the component\n  value: string,\n  onValueChange: (value: string) => mixed,\n  highlight: (value: string) => string | React.Node,\n  tabSize: number,\n  insertSpaces: boolean,\n  ignoreTabKey: boolean,\n  padding: number | string,\n  style?: {},\n\n  // Props for the textarea\n  textareaId?: string,\n  autoFocus?: boolean,\n  disabled?: boolean,\n  form?: string,\n  maxLength?: number,\n  minLength?: number,\n  name?: string,\n  placeholder?: string,\n  readOnly?: boolean,\n  required?: boolean,\n  onClick?: (e: MouseEvent) => mixed,\n  onFocus?: (e: FocusEvent) => mixed,\n  onBlur?: (e: FocusEvent) => mixed,\n  onKeyUp?: (e: KeyboardEvent) => mixed,\n  onKeyDown?: (e: KeyboardEvent) => mixed\n};\n\ntype State = {\n  capture: boolean\n};\n\ntype Record = {\n  value: string,\n  selectionStart: number,\n  selectionEnd: number\n};\n\ntype History = {\n  stack: Array<Record & { timestamp: number }>,\n  offset: number\n};\n\nconst KEYCODE_ENTER = 13;\nconst KEYCODE_TAB = 9;\nconst KEYCODE_BACKSPACE = 8;\nconst KEYCODE_Y = 89;\nconst KEYCODE_Z = 90;\nconst KEYCODE_M = 77;\nconst KEYCODE_PARENS = 57;\nconst KEYCODE_BRACKETS = 219;\nconst KEYCODE_QUOTE = 222;\nconst KEYCODE_BACK_QUOTE = 192;\nconst KEYCODE_ESCAPE = 27;\n\nconst HISTORY_LIMIT = 100;\nconst HISTORY_TIME_GAP = 3000;\n\nconst isWindows = \"navigator\" in global && /Win/i.test(navigator.platform);\nconst isMacLike =\n  \"navigator\" in global && /(Mac|iPhone|iPod|iPad)/i.test(navigator.platform);\n\nconst className = \"npm__react-simple-code-editor__textarea\";\n\nconst cssText = /* CSS */ `\n/**\n * Reset the text fill color so that placeholder is visible\n */\n.${className}:empty {\n  -webkit-text-fill-color: inherit !important;\n}\n\n/**\n * Hack to apply on some CSS on IE10 and IE11\n */\n@media all and (-ms-high-contrast: none), (-ms-high-contrast: active) {\n  /**\n    * IE doesn't support '-webkit-text-fill-color'\n    * So we use 'color: transparent' to make the text transparent on IE\n    * Unlike other browsers, it doesn't affect caret color in IE\n    */\n  .${className} {\n    color: transparent !important;\n  }\n\n  .${className}::selection {\n    background-color: #accef7 !important;\n    color: transparent !important;\n  }\n}\n`;\n\nexport default class Editor extends React.Component<Props, State> {\n  static defaultProps = {\n    tabSize: 2,\n    insertSpaces: true,\n    ignoreTabKey: false,\n    padding: 0\n  };\n\n  state = {\n    capture: true\n  };\n\n  componentDidMount() {\n    this._recordCurrentState();\n  }\n\n  _recordCurrentState = () => {\n    const input = this._input;\n\n    if (!input) return;\n\n    // Save current state of the input\n    const { value, selectionStart, selectionEnd } = input;\n\n    this._recordChange({\n      value,\n      selectionStart,\n      selectionEnd\n    });\n  };\n\n  _getLines = (text: string, position: number) =>\n    text.substring(0, position).split(\"\\n\");\n\n  _recordChange = (record: Record, overwrite?: boolean = false) => {\n    const { stack, offset } = this._history;\n\n    if (stack.length && offset > -1) {\n      // When something updates, drop the redo operations\n      this._history.stack = stack.slice(0, offset + 1);\n\n      // Limit the number of operations to 100\n      const count = this._history.stack.length;\n\n      if (count > HISTORY_LIMIT) {\n        const extras = count - HISTORY_LIMIT;\n\n        this._history.stack = stack.slice(extras, count);\n        this._history.offset = Math.max(this._history.offset - extras, 0);\n      }\n    }\n\n    const timestamp = Date.now();\n\n    if (overwrite) {\n      const last = this._history.stack[this._history.offset];\n\n      if (last && timestamp - last.timestamp < HISTORY_TIME_GAP) {\n        // A previous entry exists and was in short interval\n\n        // Match the last word in the line\n        const re = /[^a-z0-9]([a-z0-9]+)$/i;\n\n        // Get the previous line\n        const previous = this._getLines(last.value, last.selectionStart)\n          .pop()\n          .match(re);\n\n        // Get the current line\n        const current = this._getLines(record.value, record.selectionStart)\n          .pop()\n          .match(re);\n\n        if (previous && current && current[1].startsWith(previous[1])) {\n          // The last word of the previous line and current line match\n          // Overwrite previous entry so that undo will remove whole word\n          this._history.stack[this._history.offset] = { ...record, timestamp };\n\n          return;\n        }\n      }\n    }\n\n    // Add the new operation to the stack\n    this._history.stack.push({ ...record, timestamp });\n    this._history.offset++;\n  };\n\n  _updateInput = (record: Record) => {\n    const input = this._input;\n\n    if (!input) return;\n\n    // Update values and selection state\n    input.value = record.value;\n    input.selectionStart = record.selectionStart;\n    input.selectionEnd = record.selectionEnd;\n\n    this.props.onValueChange(record.value);\n  };\n\n  _applyEdits = (record: Record) => {\n    // Save last selection state\n    const input = this._input;\n    const last = this._history.stack[this._history.offset];\n\n    if (last && input) {\n      this._history.stack[this._history.offset] = {\n        ...last,\n        selectionStart: input.selectionStart,\n        selectionEnd: input.selectionEnd\n      };\n    }\n\n    // Save the changes\n    this._recordChange(record);\n    this._updateInput(record);\n  };\n\n  _undoEdit = () => {\n    const { stack, offset } = this._history;\n\n    // Get the previous edit\n    const record = stack[offset - 1];\n\n    if (record) {\n      // Apply the changes and update the offset\n      this._updateInput(record);\n      this._history.offset = Math.max(offset - 1, 0);\n    }\n  };\n\n  _redoEdit = () => {\n    const { stack, offset } = this._history;\n\n    // Get the next edit\n    const record = stack[offset + 1];\n\n    if (record) {\n      // Apply the changes and update the offset\n      this._updateInput(record);\n      this._history.offset = Math.min(offset + 1, stack.length - 1);\n    }\n  };\n\n  _handleKeyDown = (e: *) => {\n    const { tabSize, insertSpaces, ignoreTabKey, onKeyDown } = this.props;\n\n    if (onKeyDown) {\n      onKeyDown(e);\n\n      if (e.defaultPrevented) {\n        return;\n      }\n    }\n\n    if (e.keyCode === KEYCODE_ESCAPE) {\n      e.target.blur();\n    }\n\n    const { value, selectionStart, selectionEnd } = e.target;\n\n    const tabCharacter = (insertSpaces ? \" \" : \"\\t\").repeat(tabSize);\n\n    if (e.keyCode === KEYCODE_TAB && !ignoreTabKey && this.state.capture) {\n      // Prevent focus change\n      e.preventDefault();\n\n      if (e.shiftKey) {\n        // Unindent selected lines\n        const linesBeforeCaret = this._getLines(value, selectionStart);\n        const startLine = linesBeforeCaret.length - 1;\n        const endLine = this._getLines(value, selectionEnd).length - 1;\n        const nextValue = value\n          .split(\"\\n\")\n          .map((line, i) => {\n            if (\n              i >= startLine &&\n              i <= endLine &&\n              line.startsWith(tabCharacter)\n            ) {\n              return line.substring(tabCharacter.length);\n            }\n\n            return line;\n          })\n          .join(\"\\n\");\n\n        if (value !== nextValue) {\n          const startLineText = linesBeforeCaret[startLine];\n\n          this._applyEdits({\n            value: nextValue,\n            // Move the start cursor if first line in selection was modified\n            // It was modified only if it started with a tab\n            selectionStart: startLineText.startsWith(tabCharacter)\n              ? selectionStart - tabCharacter.length\n              : selectionStart,\n            // Move the end cursor by total number of characters removed\n            selectionEnd: selectionEnd - (value.length - nextValue.length)\n          });\n        }\n      } else if (selectionStart !== selectionEnd) {\n        // Indent selected lines\n        const linesBeforeCaret = this._getLines(value, selectionStart);\n        const startLine = linesBeforeCaret.length - 1;\n        const endLine = this._getLines(value, selectionEnd).length - 1;\n        const startLineText = linesBeforeCaret[startLine];\n\n        this._applyEdits({\n          value: value\n            .split(\"\\n\")\n            .map((line, i) => {\n              if (i >= startLine && i <= endLine) {\n                return tabCharacter + line;\n              }\n\n              return line;\n            })\n            .join(\"\\n\"),\n          // Move the start cursor by number of characters added in first line of selection\n          // Don't move it if it there was no text before cursor\n          selectionStart: /\\S/.test(startLineText)\n            ? selectionStart + tabCharacter.length\n            : selectionStart,\n          // Move the end cursor by total number of characters added\n          selectionEnd:\n            selectionEnd + tabCharacter.length * (endLine - startLine + 1)\n        });\n      } else {\n        const updatedSelection = selectionStart + tabCharacter.length;\n\n        this._applyEdits({\n          // Insert tab character at caret\n          value:\n            value.substring(0, selectionStart) +\n            tabCharacter +\n            value.substring(selectionEnd),\n          // Update caret position\n          selectionStart: updatedSelection,\n          selectionEnd: updatedSelection\n        });\n      }\n    } else if (e.keyCode === KEYCODE_BACKSPACE) {\n      const hasSelection = selectionStart !== selectionEnd;\n      const textBeforeCaret = value.substring(0, selectionStart);\n\n      if (textBeforeCaret.endsWith(tabCharacter) && !hasSelection) {\n        // Prevent default delete behaviour\n        e.preventDefault();\n\n        const updatedSelection = selectionStart - tabCharacter.length;\n\n        this._applyEdits({\n          // Remove tab character at caret\n          value:\n            value.substring(0, selectionStart - tabCharacter.length) +\n            value.substring(selectionEnd),\n          // Update caret position\n          selectionStart: updatedSelection,\n          selectionEnd: updatedSelection\n        });\n      }\n    } else if (e.keyCode === KEYCODE_ENTER) {\n      // Ignore selections\n      if (selectionStart === selectionEnd) {\n        // Get the current line\n        const line = this._getLines(value, selectionStart).pop();\n        const matches = line.match(/^\\s+/);\n\n        if (matches && matches[0]) {\n          e.preventDefault();\n\n          // Preserve indentation on inserting a new line\n          const indent = \"\\n\" + matches[0];\n          const updatedSelection = selectionStart + indent.length;\n\n          this._applyEdits({\n            // Insert indentation character at caret\n            value:\n              value.substring(0, selectionStart) +\n              indent +\n              value.substring(selectionEnd),\n            // Update caret position\n            selectionStart: updatedSelection,\n            selectionEnd: updatedSelection\n          });\n        }\n      }\n    } else if (\n      e.keyCode === KEYCODE_PARENS ||\n      e.keyCode === KEYCODE_BRACKETS ||\n      e.keyCode === KEYCODE_QUOTE ||\n      e.keyCode === KEYCODE_BACK_QUOTE\n    ) {\n      let chars;\n\n      if (e.keyCode === KEYCODE_PARENS && e.shiftKey) {\n        chars = [\"(\", \")\"];\n      } else if (e.keyCode === KEYCODE_BRACKETS) {\n        if (e.shiftKey) {\n          chars = [\"{\", \"}\"];\n        } else {\n          chars = [\"[\", \"]\"];\n        }\n      } else if (e.keyCode === KEYCODE_QUOTE) {\n        if (e.shiftKey) {\n          chars = ['\"', '\"'];\n        } else {\n          chars = [\"'\", \"'\"];\n        }\n      } else if (e.keyCode === KEYCODE_BACK_QUOTE && !e.shiftKey) {\n        chars = [\"`\", \"`\"];\n      }\n\n      // If text is selected, wrap them in the characters\n      if (selectionStart !== selectionEnd && chars) {\n        e.preventDefault();\n\n        this._applyEdits({\n          value:\n            value.substring(0, selectionStart) +\n            chars[0] +\n            value.substring(selectionStart, selectionEnd) +\n            chars[1] +\n            value.substring(selectionEnd),\n          // Update caret position\n          selectionStart,\n          selectionEnd: selectionEnd + 2\n        });\n      }\n    } else if (\n      (isMacLike\n        ? // Trigger undo with ⌘+Z on Mac\n          e.metaKey && e.keyCode === KEYCODE_Z\n        : // Trigger undo with Ctrl+Z on other platforms\n          e.ctrlKey && e.keyCode === KEYCODE_Z) &&\n      !e.shiftKey &&\n      !e.altKey\n    ) {\n      e.preventDefault();\n\n      this._undoEdit();\n    } else if (\n      (isMacLike\n        ? // Trigger redo with ⌘+Shift+Z on Mac\n          e.metaKey && e.keyCode === KEYCODE_Z && e.shiftKey\n        : isWindows\n        ? // Trigger redo with Ctrl+Y on Windows\n          e.ctrlKey && e.keyCode === KEYCODE_Y\n        : // Trigger redo with Ctrl+Shift+Z on other platforms\n          e.ctrlKey && e.keyCode === KEYCODE_Z && e.shiftKey) &&\n      !e.altKey\n    ) {\n      e.preventDefault();\n\n      this._redoEdit();\n    } else if (\n      e.keyCode === KEYCODE_M &&\n      e.ctrlKey &&\n      (isMacLike ? e.shiftKey : true)\n    ) {\n      e.preventDefault();\n\n      // Toggle capturing tab key so users can focus away\n      this.setState(state => ({\n        capture: !state.capture\n      }));\n    }\n  };\n\n  _handleChange = (e: *) => {\n    const { value, selectionStart, selectionEnd } = e.target;\n\n    this._recordChange(\n      {\n        value,\n        selectionStart,\n        selectionEnd\n      },\n      true\n    );\n\n    this.props.onValueChange(value);\n  };\n\n  _history: History = {\n    stack: [],\n    offset: -1\n  };\n\n  _input: ?HTMLTextAreaElement;\n\n  get session() {\n    return {\n      history: this._history\n    };\n  }\n\n  set session(session: { history: History }) {\n    this._history = session.history;\n  }\n\n  render() {\n    const {\n      value,\n      style,\n      padding,\n      highlight,\n      textareaId,\n      autoFocus,\n      disabled,\n      form,\n      maxLength,\n      minLength,\n      name,\n      placeholder,\n      readOnly,\n      required,\n      onClick,\n      onFocus,\n      onBlur,\n      onKeyUp,\n      /* eslint-disable no-unused-vars */\n      onKeyDown,\n      onValueChange,\n      tabSize,\n      insertSpaces,\n      ignoreTabKey,\n      /* eslint-enable no-unused-vars */\n      ...rest\n    } = this.props;\n\n    const contentStyle = {\n      paddingTop: padding,\n      paddingRight: padding,\n      paddingBottom: padding,\n      paddingLeft: padding\n    };\n\n    const highlighted = highlight(value);\n\n    return (\n      <div {...rest} style={{ ...styles.container, ...style }}>\n        <textarea\n          ref={c => (this._input = c)}\n          style={{\n            ...styles.editor,\n            ...styles.textarea,\n            ...contentStyle\n          }}\n          className={className}\n          id={textareaId}\n          value={value}\n          onChange={this._handleChange}\n          onKeyDown={this._handleKeyDown}\n          onClick={onClick}\n          onKeyUp={onKeyUp}\n          onFocus={onFocus}\n          onBlur={onBlur}\n          disabled={disabled}\n          form={form}\n          maxLength={maxLength}\n          minLength={minLength}\n          name={name}\n          placeholder={placeholder}\n          readOnly={readOnly}\n          required={required}\n          autoFocus={autoFocus}\n          autoCapitalize=\"off\"\n          autoComplete=\"off\"\n          autoCorrect=\"off\"\n          spellCheck={false}\n          data-gramm={false}\n        />\n        <pre\n          // aria-hidden=\"true\"\n          style={{ ...styles.editor, ...styles.highlight, ...contentStyle }}\n          {...(typeof highlighted === \"string\"\n            ? { dangerouslySetInnerHTML: { __html: highlighted + \"<br />\" } }\n            : { children: highlighted })}\n        />\n        {/* eslint-disable-next-line react/no-danger */}\n        <style type=\"text/css\" dangerouslySetInnerHTML={{ __html: cssText }} />\n      </div>\n    );\n  }\n}\n\nconst styles = {\n  container: {\n    position: \"relative\",\n    textAlign: \"left\",\n    boxSizing: \"border-box\",\n    padding: 0,\n    overflow: \"hidden\"\n  },\n  textarea: {\n    position: \"absolute\",\n    top: 0,\n    left: 0,\n    height: \"100%\",\n    width: \"100%\",\n    resize: \"none\",\n    color: \"inherit\",\n    overflow: \"hidden\",\n    MozOsxFontSmoothing: \"grayscale\",\n    WebkitFontSmoothing: \"antialiased\",\n    WebkitTextFillColor: \"transparent\"\n  },\n  highlight: {\n    position: \"relative\",\n    pointerEvents: \"none\"\n  },\n  editor: {\n    margin: 0,\n    border: 0,\n    background: \"none\",\n    boxSizing: \"inherit\",\n    display: \"inherit\",\n    fontFamily: \"inherit\",\n    fontSize: \"inherit\",\n    fontStyle: \"inherit\",\n    fontVariantLigatures: \"inherit\",\n    fontWeight: \"inherit\",\n    letterSpacing: \"inherit\",\n    lineHeight: \"inherit\",\n    tabSize: \"inherit\",\n    textIndent: \"inherit\",\n    textRendering: \"inherit\",\n    textTransform: \"inherit\",\n    whiteSpace: \"pre-wrap\",\n    wordBreak: \"keep-all\",\n    overflowWrap: \"break-word\"\n  }\n};\n"]},"metadata":{},"sourceType":"module"}